#!/usr/bin/perl
# $Id: pmake,v 1.40 2021-05-24 22:02:38-07 - - $
#-- Areman Hashemi (armhashe@ucsc.edu)"
#-- Perry Ralston (pdralsto@ucsc.edu)"

#NOTES
# remove the first n chars from a string: s/^.{$n}//s

$0 =~ s|.*/||;
use Getopt::Std;
use Data::Dumper;
use strict;
use warnings;

$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;
sub dump_hash ($\%) {
   my ($label, $hashptr) = @_;
   print STDERR "%$label: ", Data::Dumper->Dump ([$hashptr]);
}

my $STATUS = 0;
END { exit $STATUS; }
$SIG{'__WARN__'} = sub { print STDERR @_; $STATUS = 1; };
$SIG{'__DIE__'} = sub { print STDERR @_; $STATUS = 1; exit; };

# sigtoperl: x86_64 Linux unix1.lt.ucsc.edu
# sigtoperl: Sun Nov 22 17:33:55 2020
my %strsignal = (
    0 => "Unknown signal 0",
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   10 => "User defined signal 1",
   11 => "Segmentation fault",
   12 => "User defined signal 2",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   23 => "Urgent I/O condition",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

sub make_goal($);

sub modtime ($) {
    my ($filename) = @_;
    my @stat = stat $filename;
    return @stat ? $stat[9] : undef;
}

sub print_command ($) {
    my ($cmd) = @_;
    unless ($cmd =~ /^[@]/) {
        $cmd =~ s/^[-][ ]*//s;
        print "$cmd\n";
        return $cmd;
    }
    $cmd =~ s/^[@][ ]*//s;
    return $cmd;
}

sub run_command ($) {
    my ($command) = @_;
    my $status = eval {no warnings; system $command};
    return undef unless $status;
    return "$!" if $status == -1;
    my $signal = $status & 0x7F;
    my $core = $status & 0x80;
    my $exit = ($status >> 8) & 0xFF;
    return "Error $exit" unless $signal || $core;
    return ($strsignal{$signal} || "Invalid Signal Number $signal")
        . ($core ? " (core dumped)" : "");
}

my $MAKECMDGOALS;
my $Makefile = "Makefile";
my %OPTIONS;
my %GRAPH;
my %MACROS;

sub usage() { die "Usage: $0 [-mgd] [target]\n" }
sub stop($) { die "$Makefile:@_. Stop.\n" }

sub scan_cmdline() {
    getopts "dgm", \%OPTIONS;
    usage unless @ARGV <= 1;
    $MAKECMDGOALS = $ARGV[0] if @ARGV == 1;
}

sub dump_graph() {
    print STDERR "%MACROS:\n";
    for my $macro (sort keys %MACROS) {
        printf STDERR "%7d [%s] = [%s]\n",
                $MACROS{$macro}{LINE}, $macro, $MACROS{$macro}{VALUE};
    }
    print STDERR "MAKECMDGOALS = [$MAKECMDGOALS]\n";
    print STDERR "%GRAPH:\n";
    for my $target (sort keys %GRAPH) {
        my $prereqs = $GRAPH{$target}{PREREQS};
        printf STDERR "%7d [%s] :", $GRAPH{$target}{LINE}, $target;
        print STDERR " [$_]" for @$prereqs;
        print STDERR "\n";
        for my $cmd (@{$GRAPH{$target}{COMMANDS}}) {
            printf STDERR "%7d.\t[%s]\n", $cmd->{LINE}, $cmd->{CMD};;
        }
    }
}

sub rep_macro(@) {
   my ($input, $firstPreq) = @_;
   $input =~ s/\$\{(.*?)\}/$MACROS{$1}->{VALUE}/g;
   $input =~ s/\$</$firstPreq/g;
   $input =~ s/\$\$/\$/g;
   return $input;
}

sub resolve_target_wildcrd (@) {
    my ($target) = @_;
    for my $key (keys %GRAPH){
        if ($key =~ /(.)*%(.)*/) {
            my ($prefix, $suffix) = $key =~ /(.*)[%](.*)/;
            $suffix = '\\' . $suffix;
            my $key_match = $prefix? qr/($prefix)(.+)($suffix)/ : 
                qr/(.+)($suffix)/;
            if ($target =~ $key_match) {
                return $key;
            }
        }
    }
}

sub load_Makefile() {
    open my $mkfile, "<$Makefile" or die "$0: $Makefile: $!";
    my $target;
    while (defined (my $line = <$mkfile>)) {
        next if $line =~ m/^\s*(#|$)/;
        if (!$target && $line =~ m/^\s*(\S+)\s*=\s*(.*?)\s*$/) {
            $MACROS{$1} = {LINE=> $., VALUE=> $2};
        }elsif ($line =~ m/^(\S+)\s*:\s*(.*)/) {
            $target = rep_macro($1);
            $GRAPH{$target}{PREREQS} = [split ' ', rep_macro($2)];
            $GRAPH{$target}{LINE} = $.;
            $MAKECMDGOALS = $target unless $MAKECMDGOALS;
        }elsif ($line =~ m/^\t(.*)/) {
            if (defined $target) {
            my ($firstPreq) = $GRAPH{$target}{PREREQS}[0];
            push @{$GRAPH{$target}{COMMANDS}},
                    {LINE=> $., CMD=> rep_macro($1, $firstPreq)};
            }else {
            stop "$.: Command before first target";
            }
        }else {
            stop "$.: Missing separator";
        }
    }
    close $mkfile;
}

sub make_goal($) {
    my ($goal) = @_;
    my $file;
    my $resolved_wc = resolve_target_wildcrd ($goal);
    unless ($resolved_wc || $GRAPH{$goal}) {
        my $mod = modtime $goal;
        unless($mod) {
            die "Unable to continue, target unclear." 
                . " $goal did not exist\n";
        }
        return $mod;
    }
    my $new_mod_time;
    my $prereq_mod_time = 0;
    foreach (@{$GRAPH{$resolved_wc ? $resolved_wc : $goal}{PREREQS}}) {
        $file = $_;
        if ($file =~ /(.)*%(.)*/) {
            my $suffix = $file =~ s/^(.)*%//r;
            ($file = $goal) =~ s/(\.)(.)*//;
            $file = $file . $suffix;
            $new_mod_time = modtime $file;
        } else {
            $new_mod_time = make_goal($file);
        }
        $prereq_mod_time = 
            $new_mod_time if ($new_mod_time 
                && $new_mod_time > $prereq_mod_time);
    }
    my $target_mod_time = modtime $goal;
    if (!$target_mod_time || $target_mod_time < $prereq_mod_time) {
        my $commands = 
            $GRAPH{$resolved_wc ? $resolved_wc : $goal}{COMMANDS};
        if ($commands) {
            my ($cmd) = (@$commands)[0]{CMD};
            if ($file) {
                $cmd =~ s/(%\.c)/$file/;
            }
            my $exit_on_error = !($cmd =~ /^[-]/);
            my $status = run_command (print_command $cmd);
            if ($status && $exit_on_error) {
                die "$status\n";
            }
        }
    }
}

scan_cmdline;
load_Makefile;

dump_hash ("MACROS", %MACROS) if $OPTIONS{'m'};
dump_hash ("GRAPH", %GRAPH) if $OPTIONS{'g'};
dump_graph if $OPTIONS{'d'};

make_goal ($MAKECMDGOALS);
