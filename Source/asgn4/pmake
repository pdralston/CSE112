#!/usr/bin/perl
# $Id: pmake,v 1.40 2021-05-24 22:02:38-07 - - $
#-- Areman Hashemi (armhashe@ucsc.edu)"
#-- Perry Ralston (pdralsto@ucsc.edu)"

#NOTES
# remove the first n chars from a string: s/^.{$n}//s

$0 =~ s|.*/||;
use Getopt::Std;
use Data::Dumper;
use strict;
use warnings;

$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;
sub dump_hash ($\%) {
   my ($label, $hashptr) = @_;
   print STDERR "%$label: ", Data::Dumper->Dump ([$hashptr]);
}

my $STATUS = 0;
END { exit $STATUS; }
$SIG{'__WARN__'} = sub { print STDERR @_; $STATUS = 1; };
$SIG{'__DIE__'} = sub { print STDERR @_; $STATUS = 1; exit; };

# sigtoperl: x86_64 Linux unix1.lt.ucsc.edu
# sigtoperl: Sun Nov 22 17:33:55 2020
my %strsignal = (
    0 => "Unknown signal 0",
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   10 => "User defined signal 1",
   11 => "Segmentation fault",
   12 => "User defined signal 2",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   23 => "Urgent I/O condition",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

sub make_goal($);

sub modtime ($) {
    my ($filename) = @_;
    my @stat = stat $filename;
    return @stat ? $stat[9] : undef;
}

sub print_command ($) {
    my ($cmd) = @_;
    unless ($cmd =~ /^[@]/) {
        $cmd =~ s/^[-][ ]*//s;
        print "$cmd\n";
        return $cmd;
    }
    $cmd =~ s/^[@][ ]*//s;
    return $cmd;
}

sub run_command ($) {
    my ($command) = @_;
    my $status = eval {no warnings; system $command};
    return undef unless $status;
    return "$!" if $status == -1;
    my $signal = $status & 0x7F;
    my $core = $status & 0x80;
    my $exit = ($status >> 8) & 0xFF;
    return "Error $exit" unless $signal || $core;
    return ($strsignal{$signal} || "Invalid Signal Number $signal")
        . ($core ? " (core dumped)" : "");
}

my $MAKECMDGOALS;
my $Makefile = "Makefile";
my %OPTIONS;
my %GRAPH;
my %MACROS;

sub usage() { die "Usage: $0 [-mgd] [target]\n" }
sub stop($) { die "$Makefile:@_. Stop.\n" }

sub scan_cmdline() {
    getopts "dgm", \%OPTIONS;
    usage unless @ARGV <= 1;
    $MAKECMDGOALS = $ARGV[0] if @ARGV == 1;
}

sub dump_graph() {
    print STDERR "%MACROS:\n";
    for my $macro (sort keys %MACROS) {
        printf STDERR "%7d [%s] = [%s]\n",
                $MACROS{$macro}{LINE}, $macro, $MACROS{$macro}{VALUE};
    }
    print STDERR "MAKECMDGOALS = [$MAKECMDGOALS]\n";
    print STDERR "%GRAPH:\n";
    for my $target (sort keys %GRAPH) {
        my $prereqs = $GRAPH{$target}{PREREQS};
        printf STDERR "%7d [%s] :", $GRAPH{$target}{LINE}, $target;
        print STDERR " [$_]" for @$prereqs;
        print STDERR "\n";
        for my $cmd (@{$GRAPH{$target}{COMMANDS}}) {
            printf STDERR "%7d.\t[%s]\n", $cmd->{LINE}, $cmd->{CMD};;
        }
    }
}

sub load_Makefile() {
    open my $mkfile, "<$Makefile" or die "$0: $Makefile: $!";
    my $target;
    while (defined (my $line = <$mkfile>)) {
        next if $line =~ m/^\s*(#|$)/;
        if (!$target && $line =~ m/^\s*(\S+)\s*=\s*(.*?)\s*$/) {
            $MACROS{$1} = {LINE=> $., VALUE=> $2};
        }elsif ($line =~ m/^(\S+)\s*:\s*(.*)/) {
            $target = $1;
            $GRAPH{$target}{PREREQS} = [split ' ', $2];
            $GRAPH{$target}{LINE} = $.;
            $MAKECMDGOALS = $target unless $MAKECMDGOALS;
        }elsif ($line =~ m/^\t(.*)/) {
            if (defined $target) {
            push @{$GRAPH{$target}{COMMANDS}},
                    {LINE=> $., CMD=> $1};
            }else {
            stop "$.: Command before first target";
            }
        }else {
            stop "$.: Missing separator";
        }
    }
    close $mkfile;
}

sub make_goal($) {
    my ($goal) = @_;
    # if goal is not a target:
    #     if goal is a file return its modtime
    #     else stop with error "don't know how..."
    unless ($GRAPH{$goal}) {
        my $mod = modtime $goal;
        unless($mod) {
            die "Unable to continue, target unclear. $goal did not exist\n";
        }
        return $mod;
    }
    # else it is a target.
    # for each prereq:
    #     call make_goal recursively with that prereq
    #     remember the newest prereq modtime
    #     if no prereqs, the newest modtime is 0
    my $new_mod_time;
    my $prereq_mod_time = 0;
    foreach (@{$GRAPH{$goal}{PREREQS}}) {
        $new_mod_time = make_goal($_);
        $prereq_mod_time = $new_mod_time if ($new_mod_time && $new_mod_time > $prereq_mod_time);
    }
    # run the commands if either of the following is true:
    # the target file does not exist
    # or the newest prereq is newer than the target modtime
    my $target_mod_time = modtime $goal;
    if (!$target_mod_time || $target_mod_time < $prereq_mod_time) {
        my $commands = $GRAPH{$goal}{COMMANDS};
        if ($commands) {
            my $cmd = %{@$commands[0]}{CMD};
            my $exit_on_error = !($cmd =~ /^[-]/);
            my $status = run_command (print_command $cmd);
            if ($status && $exit_on_error) {
                die "$status\n";
            }
        }
    }

    
    # running a command:
    # perform macro substitution on the command
    # if the command does not begin with "@", print it
    # call run_command
    # if run_command returns undef, returnÂ 
    # print the message:
    #     if the command begins with "-" use (ignored), return
    #     if not, print the message and exit 1
}

scan_cmdline;
load_Makefile;

dump_hash ("MACROS", %MACROS) if $OPTIONS{'m'};
dump_hash ("GRAPH", %GRAPH) if $OPTIONS{'g'};
dump_graph if $OPTIONS{'d'};

make_goal ($MAKECMDGOALS);